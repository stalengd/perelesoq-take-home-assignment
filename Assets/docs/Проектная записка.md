# Проектная записка

## Использованный стэк

R3 (преемник UniRx)
Zenject (Extenject)

## Загрузка и запуск

Для изначального запуска применён распространённый подход единой точки входа на отдельной, условно пустой сцене "Bootstrap", одноимённый скрипт выполняет действия инициализации общих сервисов, после чего переходит к игре. SceneLoader загружает в Unity сцены, которые составляют уровень и скомпонованы в объект GameLevel. Цикл работы одного уровня управляется классом LevelRunner - Bootstrap создаёт его и запускает, для завершения уровня вызывает его метод Dispose().

LevelRunner выполняет инициализацию Dependency Injection (DI) сцены и запуск необходимых систем (подробнее про их запуск в следующих секциях), также вызывает у них каждый "тик" метод Update() для того чтобы они могли производить симуляцию.

## Система девайсов

Центральной системой программы является система девайсов, именно ими должен в конечном итоге управлять пользователь. Каждый девайс - класс, наследуемый от класса Device, от наследования он получает минимум, основной архитектурный принцип разработки, применённый в проекте - композиция. Девайсы определяют входные и выходные порты (DeviceInputPort, DeviceOutputPort), через которые могут быть соединены. Все взаимодействия между девайсами происходят через DeviceNetwork, ссылка на который передаётся девайсу в процессе инициализации, через неё каждый девайс может сообщать системе о включении/выключении и подаче тока на свои порты. Сам же девайс может получать информацию о состоянии своих портов через реактивные свойства (ReactiveProperty) R3 и совершать соответствующие действия, например при подаче одного из сигналов на гейт ИЛИ он подаёт ток на свой выходной порт.

Важный момент в том, что сами по себе девайсы представляют только логику и ничего не знают о их отображении на сцене.

Таким образом, девайсы образуют направленный граф, поскольку ток передаётся от выходов к входам, причём обязательным элементом является в нём девайс-источник тока (PowerSourceDevice), он контролирует текущую, максимальную мощность сети, ведёт подсчёт использованной энергии.

## Визуализация девайсов

Для отображения и взаимодействия девайсов с пользователем для каждого девайса создаётся класс, наследуемый от DevicePresenter, который получает ссылки на представления (view) девайса на сцене и UI, подписывается на реактивные свойства представлений, девайса и различных сервисов для своей работы. Например, для представления переключателя идёт подпись на событие нажатия кнопки переключения в UI, и вызов при этом событии метода переключения у девайса.

## Инициализация девайсов

Для создания девайсов в системе при запуске выбран подход "Level design first", то есть объекты на сцене диктуют какие девайсы с какими свойствами должны быть созданы. Для каждого типа девайса существует MonoBehaviour DeviceInitializer, который располагается на сцене и содержит необходимые свойства, которые будут переданы девайсу. Инициализаторы должны реализовывать метод Initialize(), который создаёт и возвращает настроенный девайс, а также через вызовы BindPort() указывает на существующие у него порты, чтобы те могли быть назначены на сцене. Также инициализаторы могут реализовывать метод InitializePresenter(), который должен создать и вернуть презентер для этого девайса.

LevelRunner при запуске уровня находит все DeviceInitializer на сцене и вызывает у них сначала Initialize(), получает из них девайс, добавляет его в сеть, затем проходится по всем инициализаторам ещё раз, вызывая InitializeConnections(), который соединяет порты девайсов на основе конфигурации инициализатора, затем InitializePresenter(), и если тот возвращает презентер - передаёт его DevicePresenterManager, который в свою очередь управляет презентерами девайсов.